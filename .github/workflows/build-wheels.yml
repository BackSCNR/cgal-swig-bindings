name: Build Wheels

on:
  push:
    branches:
      - main
    tags:
      - "v*"
  workflow_dispatch:

env:
  LATEST_CGAL_VERSION: "6.1"

jobs:
  build-wheels:
    name: Build Wheel
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, macos-15-intel, windows-latest]
        python-version: ["3.12"]
        cgal_branch: ["v6.1"]

    steps:
      - name: Checkout repository with submodules
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
          submodules: "recursive"

      - name: Configure environment (Parallel Jobs & Install Path)
        shell: bash
        run: |
          # Determine parallel jobs
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            PAR_JOBS=$NUMBER_OF_PROCESSORS
            # Normalize path to forward slashes for CMake on Windows
            # Use single quotes to prevent backslash interpretation by bash
            WS_PATH=$(cygpath -m '${{ github.workspace }}')
            echo "INSTALL_DIR=${WS_PATH}/external/install" >> $GITHUB_ENV
          elif [[ "$OSTYPE" == "darwin"* ]]; then
            PAR_JOBS=$(sysctl -n hw.logicalcpu)
            echo "INSTALL_DIR=${{ github.workspace }}/external/install" >> $GITHUB_ENV
          else
            PAR_JOBS=$(nproc)
            echo "INSTALL_DIR=${{ github.workspace }}/external/install" >> $GITHUB_ENV
          fi
          echo "Detected parallel jobs: $PAR_JOBS"
          echo "PAR_JOBS=$PAR_JOBS" >> $GITHUB_ENV

      - uses: conda-incubator/setup-miniconda@v3
        with:
          auto-update-conda: true
          python-version: ${{ matrix.python-version }}
          activate-environment: build
          channels: conda-forge

      - name: Display Python version
        shell: bash -l {0}
        run: |
          echo "Python version: ${{ matrix.python-version }}"
          python --version

      - name: Install conda dependencies
        shell: bash -l {0}
        run: |
          # Install yaml-cpp via conda on Linux/Windows (macOS builds from source)
          yaml_pkg=""
          if [[ "${{ runner.os }}" != "macOS" ]]; then
            yaml_pkg="yaml-cpp"
          fi

          conda install -y -c conda-forge boost-cpp zlib eigen mpfr numpy \
            twine delocate pycodestyle swig tbb tbb-devel wheel bzip2 \
            gmp cmake $yaml_pkg

      - name: Install system dependencies (Ubuntu)
        if: runner.os == 'Linux'
        shell: bash -l {0}
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential libgmp-dev

      - name: Install system dependencies (macOS)
        if: runner.os == 'macOS'
        shell: bash -l {0}
        run: |
          # Don't install yaml-cpp via Homebrew - requires macOS 14+
          echo "yaml-cpp will be built from source"

      - name: Install Python build dependencies
        shell: bash -l {0}
        run: |
          python -m pip install --upgrade pip
          pip install setuptools wheel twine numpy delocate

      - name: Install CGAL
        shell: bash -l {0}
        run: |
          set -xe
          pushd $HOME
          git clone --depth 1 -b ${{ matrix.cgal_branch }} https://github.com/CGAL/cgal.git
          cd cgal
          mkdir build
          cmake -B build -S . -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR -DCMAKE_BUILD_TYPE=Release
          cmake --install build
          echo "CGAL installation completed"
          echo "Contents of $INSTALL_DIR/lib:"
          ls -la $INSTALL_DIR/lib/ || echo "lib directory doesn't exist!"
          echo "All .so files in $INSTALL_DIR:"
          find $INSTALL_DIR -type f -name "*.so*" || true
          cd ..
          rm -rf cgal
          popd

      - name: Build Eigen
        shell: bash -l {0}
        run: |
          set -xe
          # Set deployment target for macOS
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            export MACOSX_DEPLOYMENT_TARGET=11.0
          fi
          cd external/eigen
          mkdir -p build
          cd build
          # Extra flags for Windows to prevent Fortran compiler search
          EXTRA_FLAGS=""
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            # Tell CMake that Fortran compiler is explicitly not found
            EXTRA_FLAGS="-DCMAKE_Fortran_COMPILER=CMAKE_Fortran_COMPILER-NOTFOUND"
          fi
          cmake .. \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR \
            -DBUILD_TESTING=OFF \
            -DEIGEN_BUILD_DOC=OFF \
            -DEIGEN_BUILD_PKGCONFIG=OFF \
            -DEIGEN_BUILD_BLAS=OFF \
            -DEIGEN_BUILD_LAPACK=OFF \
            -DEIGEN_TEST_NOQT=ON \
            -DEIGEN_LEAVE_TEST_IN_ALL_TARGET=OFF \
            $EXTRA_FLAGS
          cmake --install . --config Release
          cd ../../..

      - name: Build yaml-cpp from source
        if: runner.os == 'macOS'
        shell: bash -l {0}
        run: |
          set -xe
          # Set deployment target for macOS to ensure compatibility
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            export MACOSX_DEPLOYMENT_TARGET=11.0
            echo "Set MACOSX_DEPLOYMENT_TARGET=11.0 for macOS"
          fi
          cd $HOME
          git clone --depth 1 --branch 0.8.0 https://github.com/jbeder/yaml-cpp.git
          cd yaml-cpp
          mkdir build && cd build
          cmake .. \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR \
            -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
            -DYAML_CPP_BUILD_TESTS=OFF \
            -DYAML_CPP_BUILD_TOOLS=OFF \
            -DYAML_BUILD_SHARED_LIBS=ON
          cmake --build . --config Release -j$PAR_JOBS
          cmake --install . --config Release
          cd ../..
          rm -rf yaml-cpp

      - name: Build libnabo
        shell: bash -l {0}
        run: |
          set -xe
          # Set deployment target for macOS
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            export MACOSX_DEPLOYMENT_TARGET=11.0
          fi
          cd external/libnabo
          mkdir -p build
          cd build
          CONDA_PREFIX_PATH=$(conda info --base)/envs/build
          cmake .. \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR \
            -DCMAKE_CXX_STANDARD=17 \
            -DEIGEN_INCLUDE_DIR=$PWD/../../eigen \
            -DUSE_OPEN_MP=OFF
          cmake --build . --config Release -j$PAR_JOBS
          cmake --install . --config Release
          cd ../../..

      - name: Build libpointmatcher (Unix)
        if: runner.os != 'Windows'
        shell: bash -l {0}
        run: |
          set -xe
          # Set deployment target for macOS
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            export MACOSX_DEPLOYMENT_TARGET=11.0
          fi
          cd external/libpointmatcher
          mkdir -p build
          cd build
          cmake .. \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR \
            -DCMAKE_CXX_STANDARD=17 \
            -DEIGEN_INCLUDE_DIR=$PWD/../../eigen \
            -Dlibnabo_DIR=$INSTALL_DIR/share/libnabo/cmake \
            -DBUILD_TESTS=OFF \
            -DBUILD_TESTING=OFF \
            -DENABLE_TESTING=OFF \
            -DBUILD_EXAMPLES=OFF
          cmake --build . --config Release -j$PAR_JOBS
          cmake --install . --config Release
          # Workaround: libpointmatcher CMake config points to wrong include dir
          # Create symlink so $INSTALL_DIR/pointmatcher -> $INSTALL_DIR/include/pointmatcher
          if [[ "$OSTYPE" == "darwin"* ]] || [[ "${{ runner.os }}" == "Linux" ]]; then
             cd $INSTALL_DIR && ln -sf include/pointmatcher pointmatcher
          fi
          cd ../../..

      - name: Build libpointmatcher (Windows)
        if: runner.os == 'Windows'
        shell: bash -l {0}
        run: |
          set -xe
          # Debug: Check where yaml-cpp was installed
          echo "=== Debugging yaml-cpp installation ==="
          echo "INSTALL_DIR: $INSTALL_DIR"
          echo "Looking for yaml-cpp files:"
          find $INSTALL_DIR -name "*yaml-cpp*" -o -name "*yaml*" 2>/dev/null || echo "No yaml-cpp files found!"
          echo ""

          cd external/libpointmatcher
          # Disable gtest by making its CMakeLists.txt empty
          # This is safer than removing the directory as the parent CMakeLists still adds the subdirectory
          echo "" > contrib/CMakeLists.txt
          mkdir -p build
          cd build
          # Find yaml-cpp config directory (optional, for local builds)
          YAML_CPP_DIR=""
          if [ -d "$INSTALL_DIR/lib/cmake/yaml-cpp" ]; then
            YAML_CPP_DIR="$INSTALL_DIR/lib/cmake/yaml-cpp"
          elif [ -d "$INSTALL_DIR/share/yaml-cpp/cmake" ]; then
            YAML_CPP_DIR="$INSTALL_DIR/share/yaml-cpp/cmake"
          elif [ -d "$INSTALL_DIR/cmake" ]; then
            YAML_CPP_DIR="$INSTALL_DIR/cmake"
          elif [ -d "$INSTALL_DIR/CMake" ]; then
            YAML_CPP_DIR="$INSTALL_DIR/CMake"
          fi

          # If still not found, search for it (but don't fail if missing)
          if [ -z "$YAML_CPP_DIR" ]; then
            FOUND_CONFIG=$(find $INSTALL_DIR -name "yaml-cpp-config.cmake" -o -name "yaml-cppConfig.cmake" 2>/dev/null | head -1 || true)
            if [ -n "$FOUND_CONFIG" ]; then
              YAML_CPP_DIR=$(dirname "$FOUND_CONFIG")
            fi
          fi

          echo "yaml-cpp config directory: $YAML_CPP_DIR"

          YAML_OPT=""
          if [ -n "$YAML_CPP_DIR" ]; then
             YAML_OPT="-Dyaml-cpp_DIR=$YAML_CPP_DIR"
          fi

          cmake .. \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR \
            -DCMAKE_CXX_STANDARD=17 \
            -DEIGEN_INCLUDE_DIR=$PWD/../../eigen \
            -Dlibnabo_DIR=$INSTALL_DIR/share/libnabo/cmake \
            $YAML_OPT \
            -DBoost_USE_STATIC_LIBS=OFF \
            -DBUILD_TESTS=OFF \
            -DBUILD_TESTING=OFF \
            -DENABLE_TESTING=OFF \
            -DBUILD_EXAMPLES=OFF
          cmake --build . --config Release -j$PAR_JOBS
          cmake --install . --config Release
          cd ../../..

      - name: Build OpenGR
        shell: bash -l {0}
        run: |
          set -xe
          # Set deployment target for macOS
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            export MACOSX_DEPLOYMENT_TARGET=11.0
          fi
          cd external/OpenGR
          mkdir -p build
          cd build
          cmake .. \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=$INSTALL_DIR \
            -DIO_USE_OPENCV=OFF
          cmake --build . --config Release -j$PAR_JOBS
          cmake --install . --config Release
          cd ../../..

      - name: Build and repair wheel (Linux)
        if: runner.os == 'Linux'
        shell: bash -l {0}
        run: |
          set -ex
          CGAL_VERSION=$(perl -lan -e 'if(/CGAL_VERSION /) { $v=@F[2]; $v =~ s/-.*//; print "$v" }' $INSTALL_DIR/include/CGAL/version.h)
          CGAL_SWIG_BINDINGS_VERSION=$(git show --no-patch --format='format:%ad' --date=format:'%Y%m%d')
          CGAL_PYTHON_MODULE_VERSION=$CGAL_VERSION-$CGAL_SWIG_BINDINGS_VERSION
          echo "Package version: $CGAL_PYTHON_MODULE_VERSION"

          # Clean any existing build directories to avoid CMake cache conflicts
          find external -type d -name build -exec rm -rf {} + 2>/dev/null || true
          rm -rf build/build-python 2>/dev/null || true

          # Make build script executable
          chmod +x build-linux-wheel.sh

          # Use Docker manylinux container with custom build script
          docker pull quay.io/pypa/manylinux2014_x86_64
          docker run --rm \
            -v$INSTALL_DIR:/cgal \
            -v${PWD}:/cgal-bindings \
            -eCGAL_PYTHON_MODULE_VERSION=$CGAL_PYTHON_MODULE_VERSION \
            -ePYTHON_VERSION_MINOR=$(python -c "import sys; print(sys.version_info.minor)") \
            quay.io/pypa/manylinux2014_x86_64 \
            /cgal-bindings/build-linux-wheel.sh

          # Move wheel from wheelhouse to dist
          mkdir -p dist
          rm -f cgal-*.whl dist/*.whl 2>/dev/null || true
          cp wheelhouse/*.whl dist/

      - name: Build wheel (macOS)
        if: runner.os == 'macOS'
        shell: bash -l {0}
        run: |
          set -ex
          export MACOSX_DEPLOYMENT_TARGET=11.0
          export CMAKE_PREFIX_PATH=$INSTALL_DIR
          CGAL_VERSION=$(perl -lan -e 'if(/CGAL_VERSION /) { $v=@F[2]; $v =~ s/-.*//; print "$v" }' $INSTALL_DIR/include/CGAL/version.h)
          CGAL_SWIG_BINDINGS_VERSION=$(git show --no-patch --format='format:%ad' --date=format:'%Y%m%d')
          CGAL_PYTHON_MODULE_VERSION=$CGAL_VERSION-$CGAL_SWIG_BINDINGS_VERSION
          echo "Package version: $CGAL_PYTHON_MODULE_VERSION"
          export CGAL_PYTHON_MODULE_VERSION
          mkdir -p build/build-python/CGAL
          python setup.py bdist_wheel \
            --cmake-prefix-path=$INSTALL_DIR \
            --python-executable=$(which python)
          # Set DYLD_LIBRARY_PATH so delocate-wheel can find TBB and other libraries
          CONDA_LIB=$(conda info --base)/envs/build/lib
          export DYLD_LIBRARY_PATH=$CONDA_LIB:$INSTALL_DIR/lib:$DYLD_LIBRARY_PATH
          echo "=== Debugging macOS library deployment targets ==="
          echo "Checking deployment targets of libraries in $INSTALL_DIR/lib:"
          for lib in $INSTALL_DIR/lib/*.dylib; do
            if [ -f "$lib" ]; then
              echo "$(basename $lib): $(otool -l "$lib" | grep -A 3 LC_VERSION_MIN_MACOSX | grep version || echo 'no version info')"
            fi
          done
          echo ""
          echo "yaml-cpp deployment target:"
          find $INSTALL_DIR -name "*yaml-cpp*.dylib" -exec otool -l {} \; | grep -A 3 LC_VERSION_MIN_MACOSX || echo "Not found or no version info"
          echo ""
          echo "=== Running delocate-wheel ==="
          delocate-wheel -v -w fixed_wheel dist/*.whl
          rm dist/*.whl
          cp fixed_wheel/*.whl dist/

      - name: Build wheel (Windows)
        if: runner.os == 'Windows'
        shell: bash -l {0}
        run: |
          set -ex
          CONDA_ENV_DIR=$(conda env list --json | jq -r '.envs | .[] | select(test("build"))')
          CONDA_ENV_DIR="$CONDA_ENV_DIR\\Library"
          export CMAKE_PREFIX_PATH="${CONDA_ENV_DIR};$(cygpath -w $INSTALL_DIR)"
          export LIB=${CONDA_ENV_DIR}\\lib
          CGAL_VERSION=$(perl -lan -e 'if(/CGAL_VERSION /) { $v=@F[2]; $v =~ s/-.*//; print "$v" }' $INSTALL_DIR/include/CGAL/version.h)
          CGAL_SWIG_BINDINGS_VERSION=$(git show --no-patch --format='format:%ad' --date=format:'%Y%m%d')
          CGAL_PYTHON_MODULE_VERSION=$CGAL_VERSION-$CGAL_SWIG_BINDINGS_VERSION
          echo "Package version: $CGAL_PYTHON_MODULE_VERSION"
          export CGAL_PYTHON_MODULE_VERSION
          mkdir -p build/build-python/CGAL
          python setup.py bdist_wheel \
            --cmake-prefix-path="${CMAKE_PREFIX_PATH}" \
            --python-executable=$(which python)
          pip install delvewheel
          delvewheel repair --ignore-in-wheel dist/*.whl -w fixed_wheels
          rm dist/*.whl
          mv fixed_wheels/*.whl dist/

      - name: Check wheel
        shell: bash -l {0}
        run: |
          python -m twine check dist/*.whl

      - name: Test wheel installation
        shell: bash -l {0}
        run: |
          set -ex
          pip install dist/*.whl
          python -c "
          from CGAL import CGAL_Point_set_processing_3 as psp
          print('Testing registration functions...')
          assert hasattr(psp, 'register_point_sets_opengr'), 'OpenGR missing'
          assert hasattr(psp, 'register_point_sets_pointmatcher'), 'PointMatcher missing'
          assert hasattr(psp, 'ICP_config_wrapper'), 'ICP_config_wrapper missing'
          assert hasattr(psp, 'ICP_config_vector'), 'ICP_config_vector missing'
          print('âœ“ All registration functions available!')
          "

      - name: Upload wheel artifact
        uses: actions/upload-artifact@v5
        with:
          name: cgal-wheel-${{ github.run_id }}-${{ matrix.os }}-${{ matrix.python-version }}
          path: dist/*.whl

  test-wheels:
    name: Test Wheel
    needs: build-wheels
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ["3.12"]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: ${{ matrix.python-version }}

      - name: Download wheel
        uses: actions/download-artifact@v6
        with:
          name: cgal-wheel-${{ github.run_id }}-${{ matrix.os }}-${{ matrix.python-version }}
          path: dist

      - name: Install and test wheel
        shell: bash
        run: |
          set -ex
          pip install dist/*.whl
          cd examples/python
          python test_registration_install.py

      - name: Run registration example
        shell: bash
        run: |
          set -ex
          cd examples/python
          python Point_set_registration_example.py

  release:
    name: Upload Release Wheels
    needs: [build-wheels, test-wheels]
    runs-on: ubuntu-latest
    timeout-minutes: 60
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Download all wheels
        uses: actions/download-artifact@v6
        with:
          path: wheels
          pattern: cgal-wheel-${{ github.run_id }}-*
          merge-multiple: true

      - name: Display wheels
        run: |
          ls -lah wheels/

      - name: Upload to GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: wheels/*.whl
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
